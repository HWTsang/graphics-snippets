<script id="draw-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  
  attribute vec3 inPos;
  attribute vec3 inNV;
  attribute vec3 inCol;

  varying vec3  vertPos;
  varying vec3  vertNV;
  varying vec3  vertCol;
   
  uniform mat4 u_projectionMat44;
  uniform mat4 u_viewMat44;
  uniform mat4 u_modelMat44;
  uniform vec4 u_clipPlane;
  
  void main()
  {   
      mat4 mv       = u_viewMat44 * u_modelMat44; 
      vertCol       = inCol;
      vertNV        = normalize(mat3(mv) * inNV);
      vec4 viewPos  = mv * vec4( inPos, 1.0 );
      vertPos       = viewPos.xyz;
      gl_Position   = u_projectionMat44 * viewPos;
  }
</script>

<script id="draw-shader-fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec3  vertPos;
  varying vec3  vertNV;
  varying vec3  vertCol;
  
  void main()
  {
      vec3  vl     = vec3(0.0, 0.0, 1.0);
      float kd     = max(0.0, dot(vertNV, vl)); 
      vec3 color   = vertCol * (0.1 + kd * 1.2);
      gl_FragColor = vec4( color.rgb, 1.0 );
  } 
</script>

<style>
html,body { margin: 0; overflow: hidden; }
#gui { position : absolute; top : 0; left : 0; }
#ref-link { position : absolute; bottom : 0; left : 0; }  
</style>

<body>

<div><form id="gui" name="inputs"><table>
    <tr> <td> <font color=#40f040>form</font> </td> <td>
        <select id="mesh">
            <option value="0">tetrahedron</option>
            <option value="1">cube</option>
            <option value="2">icosahedron</option>
            <option value="3">sphere sliced</option>
            <option value="4">torus</option>
            <option value="5" selected="selected">trefoil knot</option>
            <option value="6">torus knot</option-->
        </select>
    </td> </tr>
</table></form></div>

<!--div id="ref-link">
  <a href=""> 
  </a>
</div-->

<canvas id="canvas" style="border: none;"></canvas>

<script type="text/javascript">

(function loadscene() {

let gl;

class App {

    constructor() {
        this.canvas = document.getElementById( "canvas");
        //gl = canvas.getContext( "webgl2" );
        //if ( !gl )
        //    gl = canvas.getContext( "experimental-webgl" );
        if ( !gl )
            gl = canvas.getContext( "webgl" );
        if ( !gl )
            return null;
        
        //let ext_standard_derivatives = gl.getExtension("OES_standard_derivatives");  // dFdx, dFdy
        //if (!ext_standard_derivatives)
        //    console.log('no standard derivatives support (no dFdx, dFdy)');
        //if (!ext_vao)
        //    console.log('no vertex array objects support');
       
        this.progDraw = new ShProg( 
            [ { source : "draw-shader-vs", stage : gl.VERTEX_SHADER },
                { source : "draw-shader-fs", stage : gl.FRAGMENT_SHADER }
            ] );
        if ( !this.progDraw.progObj )
            return null;
        this.progDraw.inPos = this.progDraw.AttrI("inPos");
        this.progDraw.inNV  = this.progDraw.AttrI("inNV");
        this.progDraw.inCol = this.progDraw.AttrI("inCol");

        let meshes = [ 
            new MeshTetrahedron(),
            new MeshCube(),
            new MeshIcosahedron(),
            new MeshSphereSlice(16, 32),
            new MeshTorus(32, 32),
            new MeshTrefoilKnot(256, 32),
            new MeshTorusKnot(512, 32, 3, 7),
        ];

        document.getElementById( "mesh" ).value = Math.floor((Math.random() * meshes.length));

        this.meshes = [];
        for (let i = 0; i < meshes.length; ++ i ) {
            this.meshes.push( new VertexBuffer( gl,
                    [ { data : meshes[i].v, attrSize : 3, attrLoc : this.progDraw.inPos },
                      { data : meshes[i].n, attrSize : 3, attrLoc : this.progDraw.inNV },
                      { data : meshes[i].c, attrSize : 3, attrLoc : this.progDraw.inCol } ],
                    meshes[i].e ) );
        }

        this.resize(); 
        this.camera = new Camera( [0, 2, 0], [0, 0, 0], [0, 0, 1], 90, this.vp_size, 0.5, 100 );

        var self = this;
        window.onresize = function() { self.resize(); }
    }    

    resize() {
        //vp_size = [gl.drawingBufferWidth, gl.drawingBufferHeight];
        this.vp_size = [window.innerWidth, window.innerHeight]
        this.canvas.width = this.vp_size[0];
        this.canvas.height = this.vp_size[1];
    }

    draw(deltaMS){
        
        var mesh = document.getElementById( "mesh" ).value;

        // setup view projection and model
        this.camera.Update( this.vp_size );
        var modelMat = Mat44.ident();
        modelMat = this.camera.autoModelMatrix;
            
        gl.viewport( 0, 0, this.vp_size[0], this.vp_size[1] );
        gl.enable( gl.DEPTH_TEST );
        gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        // set up draw shader
        this.progDraw.Use();
        this.progDraw.SetM44("u_projectionMat44", this.camera.perspective);
        this.progDraw.SetM44("u_viewMat44", this.camera.orbit);
        this.progDraw.SetM44("u_modelMat44", modelMat);
        
        // draw scene
        this.meshes[mesh].Draw();
    }
}

/* TODO $$$ mesh classes
   e.g. sphere_tessellated, tube, cone, arrow 
*/

class MeshTetrahedron {
    constructor() {
        //TODO $$$ (tangents), (binormals)
        let s_8_9 = Math.sqrt(8/9);
        let s_2_9 = Math.sqrt(2/9);
        let s_2_3 = Math.sqrt(2/3);
        let v = [ 0,0,1, s_8_9,0,-1/3, -s_2_9,s_2_3,-1/3, -s_2_9,-s_2_3,-1/3 ]
        let c = [ 1.0, 0.0, 0.0,  1.0, 1.0, 0.0,  0.0, 0.0, 1.0,  0.0, 1.0, 0.0 ];
        let t = [ 1,1, 0,0, 1,0, 0,1 ];
        let ni = [ 3, 1, 2, 0 ];
        let e = [ 0, 1, 2, 0, 2, 3, 0, 3, 1, 1, 3, 2 ];  
        this.v = [], this.n = []; this.c = []; this.t = [];
        for ( let is = 0; is < 4; ++ is ) {
            for ( let ip = 0; ip < 3; ++ ip ) { 
                let i = is*3+ip;
                this.v.push( v[e[i]*3], v[e[i]*3+1], v[e[i]*3+2] ); 
                this.n.push( -v[ni[is]*3], -v[ni[is]*3+1], -v[ni[is]*3+2] ); 
                this.c.push( c[is*3], c[is*3+1], c[is*3+2] ); 
                this.t.push( t[e[i]*2], t[e[i]*2]+1 ); 
            } 
        }
    }
};

class MeshCube {
    constructor() {
        //TODO $$$ (tangents), (binormals)
        let v = [ -1,-1,1,  1,-1,1,  1,1,1, -1,1,1, -1,-1,-1,  1,-1,-1,  1,1,-1, -1,1,-1 ];
        let c = [ 1.0, 0.0, 0.0,   1.0, 0.5, 0.0,    1.0, 0.0, 1.0,   1.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 0.0, 1.0 ];
        let n = [ 0,0,1, 1,0,0, 0,0,-1, -1,0,0, 0,1,0, 0,-1,1 ];
        let t = [ 0,0, 1,0, 1,1, 0,1 ];
        let e = [ 0, 1, 2, 3, 1, 5, 6, 2, 5, 4, 7, 6, 4, 0, 3, 7, 3, 2, 6, 7, 1, 0, 4, 5 ];  
        this.v = []; this.n = []; this.c = []; this.t = [];
        for ( let i = 0; i < e.length; ++ i ) this.v.push( v[e[i]*3]*0.707, v[e[i]*3+1]*0.707, v[e[i]*3+2]*0.707 );
        for ( let is = 0; is < 6; ++ is ) {
            for ( let ip = 0; ip < 4; ++ ip ) { 
                this.n.push( n[is*3], n[is*3+1], n[is*3+2] ); 
                this.c.push( c[is*3], c[is*3+1], c[is*3+2] ); 
                this.t.push( t[ip*2], t[ip*2+1] ); 
            } 
        }
        this.e = [];
        for ( let i = 0; i < e.length; i += 4 ) { this.e.push( i, i+1, i+2, i, i+2, i+3 ); }   
    }
};

class MeshIcosahedron{
    constructor() {
        //TODO $$$ (tangents), (binormals), texture coordiantes
        let v = [ 0,0,1, 0.894,0,0.447, 0.276,0.851,0.447, -0.724,0.526,0.447, -0.724,-0.526,0.447, 0.276,-0.851, 0.447,
                  0.724,0.526,-0.447, -0.276,0.851,-0.447, -0.894,0,-0.447, -0.276,-0.851,-0.447, 0.724,-0.526,-0.447, 0,0,-1 ];
        let c = [ 1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0, 1.0,1.0,0.0, 1.0,0.0,1.0, 1.0,0.5,0.0, 0.0,1.0,1.0 ];
        let e = [ 2,0,1, 3,0,2, 4,0,3, 5,0,4, 1,0,5, 11,7,6, 11,8,7, 11,9,8, 11,10,9, 11,6,10,
                  1,6,2, 2,7,3, 3,8,4, 4,9,5, 5,10,1, 2,6,7, 3,7,8, 4,8,9, 5,9,10, 1,10,6 ]
        this.v = []; this.n = []; this.c = [];
        for ( let i = 0; i < e.length; ++ i ) this.v.push( v[e[i]*3], v[e[i]*3+1], v[e[i]*3+2] );
        for ( let i = 0; i < e.length; ++ i ) {
           this.v.push( v[e[i]*3], v[e[i]*3+1], v[e[i]*3+2] );
        }
        for ( let fi = 0; fi < this.v.length/9; ++ fi ) {
            let nv = [0, 0, 0];
            for ( let ti = 0; ti < 3; ++ ti ) {
                nv[0] += this.v[(fi*3+ti)*3];
                nv[1] += this.v[(fi*3+ti)*3+1];
                nv[2] += this.v[(fi*3+ti)*3+2];
            }
            nv = Vec3.normalize(nv);
            let ci = fi % (c.length/3);
            for ( let ti = 0; ti < 3; ++ ti ) {
                this.n.push( nv[0], nv[1], nv[2] );
                this.c.push( c[ci*3], c[ci*3+1], c[ci*3+2] );
            }
        }
    }
};

class MeshSphereSlice{
    constructor(nl, nc, r, c) {
        //TODO $$$ (tangents), (binormals)
        nl = nl || 16;
        nc = nc || 32;
        r = r || 1;
        c = c || [0.7, 0.7, 0.2];
        this.v = []; this.n = []; this.c = [];  this.t = [];
        let nc_2 = nc / 2;
        for ( let tbI = 0; tbI <= nl; tbI ++ )
        {
            var v = ( 1.0 - tbI / nl );
            var z = Math.sin( ( 1.0 - 2.0 * tbI / nl ) * Math.PI/2.0 );
            var cU = Math.sqrt( 1.0 - z*z );
            // create 2 hemispheres, so would be possible to wrap 1 texture at both hemispheres 
            for ( let hi = 0; hi < 2; ++ hi ) {
                for ( let i = 0; i <= nc_2; i ++ ) {
                    var u = i / nc_2;
                    var a = Math.PI * u + hi * Math.PI;
                    var x = Math.cos( a ) * cU;
                    var y = Math.sin( a ) * cU;
                    this.v.push( r*x, r*y, r*z );
                    this.n.push( x, y, z );
                    this.t.push( hi*0.5+u*0.5, v );
                    this.c.push( c[0], c[1], c[2] );
                }
            }
        }
         
        this.e = [];
        
        // bottom cap
        var cs_2 = nc_2 + 1;
        var cs = cs_2 * 2;
        for ( let i = 0; i < nc_2; i ++ ) { this.e.push( cs + i, cs + i + 1, i ); }
        for ( let i = nc_2+1; i < 2*nc_2+1; i ++ ) { this.e.push( cs+i, cs+i+1, i ); }
        // discs
        for ( let tbI = 1; tbI < nl - 1; tbI ++ ) {
            for ( let hi = 0; hi < 2; ++ hi ) {
                var rsi = tbI*cs + hi*cs_2;
                var nrsi = (tbI+1)*cs + hi*cs_2;
                for ( var i = 0; i < nc_2; i ++ ) { this.e.push( rsi+i, nrsi+i, nrsi+i+1, rsi+i, nrsi+i+1, rsi+i+1 ); }
            }
        }
        // top cap
        var si = (nl-1) * cs;
        for ( let i = 0; i < nc_2; i ++ ) { this.e.push( si + i + 1, si + i, si + i + cs ); }
        for ( let i = nc_2+1; i < 2*nc_2+1; i ++ ) { this.e.push( si+i+1, si+i, si+i+cs ); }
    }
};

class MeshTorus{
    constructor(nl, nc, r, rt, c) {
        //TODO $$$ (tangents), (binormals), texture coordiantes
        nl = nl || 32;
        nc = nc || 32;
        c = c || [0.9, 0.5, 0.1];
        r = r || 0.7;
        rt = rt || 0.3;
        this.v = []; this.n = []; this.c = []; this.e = [];
        for ( let i_c = 0; i_c < nl; ++ i_c ) {
            let tcpt = [Math.cos(2 * Math.PI * i_c / nl), Math.sin(2 * Math.PI * i_c / nl) ];
            for ( let i_t = 0; i_t < nc; ++ i_t ) {
                let tX = Math.cos(2 * Math.PI * i_t / nc);
                let tY = Math.sin(2 * Math.PI * i_t / nc);
                let p  = [ tcpt[0] * (r + tX*rt), tcpt[1] * (r + tX*rt), tY*rt ];
                let n  = [ p[0] - tcpt[0]*r, p[1] - tcpt[1]*r, p[2] ];
                this.v.push( p[0], p[1], p[2] );
                this.n.push( n[0], n[1], n[2] );
                this.c.push( c[0], c[1], c[2] );
                let i_cn = (i_c+1) % nl;
                let i_tn = (i_t+1) % nc;
                let i_c0 = i_c * nc; 
                let i_c1 = i_cn * nc; 
                this.e.push( i_c0+i_t, i_c1+i_t, i_c0+i_tn, i_c0+i_tn, i_c1+i_t, i_c1+i_tn );
            }
        }
    }
};

class MeshTrefoilKnot{
    constructor(slices, stacks, ra, rb, rc, rd, c) {
        //TODO $$$ (tangents), (binormals)
        slices = slices || 256;
        stacks = stacks || 32;
        this.ra = ra || 0.6;
        this.rb = ra || 0.2;
        this.rc = ra || 0.4;
        this.rd = rd || 0.175;
        c = c || [0.9, 0.5, 0.1];
        this.v = []; this.n = []; this.c = []; this.e = []; this.t = [];
        
        let ds = 1.0 / slices;
        let dt = 1.0 / stacks;
        for ( let s = 0; s < 1 - ds / 2; s += ds) {
            for ( let t = 0; t < 1 - dt / 2; t += dt ) {
                let E = 0.01;
                let p = this.compute( s, t );
                let u = this.compute( s + E, t );
                u = Vec3.sub( u, p );
                let v = this.compute( s, t + E );
                v = Vec3.sub( v, p );
                let n = Vec3.normalize(Vec3.cross( u, v ));
                this.v.push( p[0], p[1], p[2] );
                this.n.push( n[0], n[1], n[2] );
                this.t.push( s * 18.0, t );
                this.c.push( c[0], c[1], c[2] );
            }
        }

        this.e = [];
        let vertexCount = this.v.length/3;
        let n = 0;
        for ( let i = 0; i < slices; ++ i ) {
            for ( let j = 0; j < stacks; ++ j ) { 
                this.e.push( n + j, n + (j + 1) % stacks, (n + j + stacks) % vertexCount );
                this.e.push( (n + j + stacks) % vertexCount, (n + (j + 1) % stacks) % vertexCount, (n + (j + 1) % stacks + stacks) % vertexCount );
            }
            n += stacks;
        }
    }

    compute( s, t ) {
        let TwoPi = Math.PI * 2;
        let a = this.ra;
        let b = this.rb;
        let c = this.rc;
        let d = this.rd;
        let u = ( 1 - s ) * 2 * TwoPi;
        let v = t * TwoPi;
        let r = a + b * Math.cos( 1.5 * u );
        let x = r * Math.cos( u );
        let y = r * Math.sin( u );
        let z = c * Math.sin( 1.5 * u );

        let dv = [
            -1.5 * b * Math.sin( 1.5 * u ) * Math.cos( u ) - ( a + b * Math.cos( 1.5 * u ) ) * Math.sin( u ),
            -1.5 * b * Math.sin( 1.5 * u ) * Math.sin( u ) + ( a + b * Math.cos( 1.5 * u ) ) * Math.cos( u ),
            1.5 * c * Math.cos( 1.5 * u )
        ];
        let q = Vec3.normalize( dv );
        let qvn = Vec3.normalize( [ q[1], -q[0], 0 ] );
        let ww = Vec3.cross( q, qvn );
        let range = [
            x + d * ( qvn[0] * Math.cos( v ) + ww[0] * Math.sin( v ) ),
            y + d * ( qvn[1] * Math.cos( v ) + ww[1] * Math.sin( v ) ),
            z + d * ww[2] * Math.sin( v )
        ]    
        return range;
    }
};

class MeshTorusKnot{
    constructor(slices, stacks, p_, q_, ra, rb, c) {
        //TODO $$$ (tangents), (binormals)
        slices = slices || 512;
        stacks = stacks || 32;
        p_ = p_ || 7;
        q_ = q_ || 3; 
        this.ra = ra || 0.35;
        this.rb = ra || 0.3;
        c = c || [0.9, 0.5, 0.1];
        this.v = []; this.n = []; this.c = []; this.e = []; this.t = [];
        
        let ds = 1.0 / slices;
        let dt = 1.0 / stacks;
        for ( let s = 0; s < 1 - ds / 2; s += ds) {
            for ( let t = 0; t < 1 - dt / 2; t += dt ) {
                let E = 0.001;
                let p = this.compute( s, t, p_, q_ );
                let u = this.compute( s - E, t, p_, q_ );
                u = Vec3.sub( u, p );
                let v = this.compute( s, t + E, p_, q_ );
                v = Vec3.sub( v, p );
                let n = Vec3.normalize(Vec3.cross( u, v ));
                this.v.push( p[0], p[1], p[2] );
                this.n.push( n[0], n[1], n[2] );
                this.t.push( s * 3.0 * p_ * q_, t );
                this.c.push( c[0], c[1], c[2] );
            }
        }

        this.e = [];
        let vertexCount = this.v.length/3;
        let n = 0;
        for ( let i = 0; i < slices; ++ i ) {
            for ( let j = 0; j < stacks; ++ j ) {
                
                this.e.push( n + j, n + (j + 1) % stacks, (n + j + stacks) % vertexCount );
                this.e.push( (n + j + stacks) % vertexCount, (n + (j + 1) % stacks) % vertexCount, (n + (j + 1) % stacks + stacks) % vertexCount );
            }
            n += stacks;
        }
    }

    compute( s, t, p, q ) {
        var tube_rad = this.ra;
        var torus_rad = this.rb;

        /*
        var phi1 = ( s - 1 / ( q * Math.PI ) ) * Math.PI * 2;
        var r1 = Math.cos( q * phi1 ) + 2;
        var x1 = r1 * Math.cos( p * phi1 );
        var y1 = r1 * Math.sin( p * phi1 );
        var z1 = - Math.sin( q * phi1 );

        var phi2 = ( s + 1 / ( q * Math.PI ) ) * Math.PI * 2;
        var r2 = Math.cos( q * phi2 ) + 2;
        var x2 = r2 * Math.cos( p * phi2 );
        var y2 = r2 * Math.sin( p * phi2 );
        var z2 = - Math.sin( q * phi2 );

        var dir = vec3.create( [ x2 - x1, y2 - y1, z2 - z1 ] );
        vec3.normalize( dir );
        var dir_xy = vec3.create( [ dir[0], dir[1], 0 ] );
        vec3.normalize( dir_xy );
        var dir_xy_len = Math.sqrt( dir[0] * dir[0] + dir[1] + dir[1] );

        var phi = s * Math.PI * 2;
        var r = Math.cos( q * phi ) + 2;
        var x = r * Math.cos( p * phi );
        var y = r * Math.sin( p * phi );
        var z = - Math.sin( q * phi );
        
        var beta = t * Math.PI * 2;
        var tube_x = Math.sin( beta );
        var tube_y = Math.cos( beta );

        var vertex = vec3.create();
        vertex[0] = x + tube_rad * tube_x * -dir_xy[1] + tube_rad * tube_y * dir_xy_len * dir_xy[0]; 
        vertex[1] = y + tube_rad * tube_x * dir_xy[0] + tube_rad * tube_y * dir_xy_len * dir_xy[1]; 
        vertex[2] = z + tube_rad * tube_y * dir[2]; 
        */

        var phi = s * Math.PI * 2;
        var r = Math.cos( q * phi ) + 2;
        var dir_x = Math.cos( p * phi );
        var dir_y = Math.sin( p * phi );
        var x = r * dir_x;
        var y = r * dir_y;
        var z = - Math.sin( q * phi );
        
        var beta = t * Math.PI * 2;
        var tube_x = Math.sin( beta );
        var tube_y = Math.cos( beta );

        var dir_circle = Vec3.normalize( [ -y, x, 0 ] );
        var dir_up = Vec3.normalize( [ 0, Math.cos( q * phi ), 1 ] );
        var vertex = [
            x + tube_rad * tube_x * dir_x + tube_rad * tube_y * dir_up[1] * dir_circle[0],
            y + tube_rad * tube_x * dir_y + tube_rad * tube_y * dir_up[1] * dir_circle[1], 
            z + tube_rad * tube_y * dir_up[2]
        ]; 
        vertex[0] *= torus_rad;  
        vertex[1] *= torus_rad;
        vertex[2] *= torus_rad;
        return vertex;
    }
};


class ShProg {
    constructor(shaderList) {
        let shaderObjs = [];
        for (let i_sh = 0; i_sh < shaderList.length; ++i_sh) {
            let shderObj = this.Compile(shaderList[i_sh].source, shaderList[i_sh].stage);
            if (shderObj) shaderObjs.push(shderObj);
        }
        this.progObj = this.Link(shaderObjs)
        if (this.progObj) {
            this.attrInx = {};
            var noOfAttributes = gl.getProgramParameter(this.progObj, gl.ACTIVE_ATTRIBUTES);
            for (var i_n = 0; i_n < noOfAttributes; ++i_n) {
                var name = gl.getActiveAttrib(this.progObj, i_n).name;
                this.attrInx[name] = gl.getAttribLocation(this.progObj, name);
            }
            this.uniLoc = {};
            var noOfUniforms = gl.getProgramParameter(this.progObj, gl.ACTIVE_UNIFORMS);
            for (var i_n = 0; i_n < noOfUniforms; ++i_n) {
                var name = gl.getActiveUniform(this.progObj, i_n).name;
                this.uniLoc[name] = gl.getUniformLocation(this.progObj, name);
            }
        }
    }

    AttrI(name) { return this.attrInx[name]; }
    UniformL(name) { return this.uniLoc[name]; }
    Use() { gl.useProgram(this.progObj); }
    SetI1(name, val) { if (this.uniLoc[name]) gl.uniform1i(this.uniLoc[name], val); }
    SetF1(name, val) { if (this.uniLoc[name]) gl.uniform1f(this.uniLoc[name], val); }
    SetF2(name, arr) { if (this.uniLoc[name]) gl.uniform2fv(this.uniLoc[name], arr); }
    SetF3(name, arr) { if (this.uniLoc[name]) gl.uniform3fv(this.uniLoc[name], arr); }
    SetF4(name, arr) { if (this.uniLoc[name]) gl.uniform4fv(this.uniLoc[name], arr); }
    SetM33(name, mat) { if (this.uniLoc[name]) gl.uniformMatrix3fv(this.uniLoc[name], false, mat); }
    SetM44(name, mat) { if (this.uniLoc[name]) gl.uniformMatrix4fv(this.uniLoc[name], false, mat); }
    
    Compile(source, shaderStage) {
        let shaderScript = document.getElementById(source);
        if (shaderScript)
            source = shaderScript.text;
        let shaderObj = gl.createShader(shaderStage);
        gl.shaderSource(shaderObj, source);
        gl.compileShader(shaderObj);
        let status = gl.getShaderParameter(shaderObj, gl.COMPILE_STATUS);
        if (!status) alert(gl.getShaderInfoLog(shaderObj));
        return status ? shaderObj : null;
    }
    
    Link(shaderObjs) {
        let prog = gl.createProgram();
        for (let i_sh = 0; i_sh < shaderObjs.length; ++i_sh)
            gl.attachShader(prog, shaderObjs[i_sh]);
        gl.linkProgram(prog);
        status = gl.getProgramParameter(prog, gl.LINK_STATUS);
        if ( !status ) alert(gl.getProgramInfoLog(prog));
        return status ? prog : null;
    } 
}

class VertexBuffer {
    constructor(gl, attribs, indices, type) {
        this.gl = gl;
        this.buf = [];
        this.attr = [];
        if ( indices )
            this.inxLen = indices.length;
        this.primitive_type = type ? type : gl.TRIANGLES;
        if ( this.gl.createVertexArray )
        {
            this.vao = this.gl.createVertexArray();
            this.gl.bindVertexArray(this.vao);
            this.Prepare = function() { this.gl.bindVertexArray(this.vao); };
            this.Release = function() { this.gl.bindVertexArray(null); };
        }
        else 
        if ( this.ext_vao = gl.getExtension("OES_vertex_array_object") ) {
            this.vao = this.ext_vao .createVertexArrayOES();
            this.ext_vao.bindVertexArrayOES(this.vao);
            this.Prepare = function() { this.ext_vao.bindVertexArrayOES(this.vao); };
            this.Release = function() { this.ext_vao.bindVertexArrayOES(null); };
        }
        else {
            this.Prepare = function() { 
                this.DefineVBOs(); 
                if ( this.inxLen > 0 ) this.gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.inx); 
            };
            this.Release = function() { 
                if ( this.inxLen > 0 )
                    this.gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                for (let i=0; i<this.buf.length; ++i)
                    this.gl.disableVertexAttribArray(this.attr[i].loc);
            };
        }

        for (let i=0; i<attribs.length; ++i) {
            this.buf.push(this.gl.createBuffer());
            this.attr.push({ size : attribs[i].attrSize, loc : attribs[i].attrLoc, no_of: attribs[i].data.length/attribs[i].attrSize });
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.buf[i]);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( attribs[i].data ), gl.STATIC_DRAW);
        }
        this.gl.bindBuffer(gl.ARRAY_BUFFER, null);
        if ( this.inxLen > 0 ) {
            this.inx = this. gl.createBuffer();
            this.gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.inx);
            this.gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( indices ), gl.STATIC_DRAW);
            if ( !this.vao )
                this.gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        if ( this.ext_vao || this.vao ) {
            this.DefineVBOs();
            this.Release()
        }
    }

    Draw() {
        this.Prepare();
        if (this.inxLen > 0)
            this.gl.drawElements(this.primitive_type, this.inxLen, gl.UNSIGNED_SHORT, 0);
        else
            this.gl.drawArrays(this.primitive_type, 0, this.attr[0].no_of);
        this.Release();
    }

    DefineVBOs() {
        for (let i=0; i<this.buf.length; ++i) {
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.buf[i]);
            this.gl.vertexAttribPointer(this.attr[i].loc, this.attr[i].size, gl.FLOAT, false, 0, 0);
            this.gl.enableVertexAttribArray(this.attr[i].loc);
        }
        this.gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
}


// TODO $$$ attenuation
class Camera {
    constructor( pos, target, up, fov_y, vp, near, far ) {
        this.pos = pos;
        this.target = target;
        this.up = up;
        this.fov_y = fov_y;
        this.vp = vp;
        this.near = near;
        this.far = far;
        this.orbit_mat = this.current_orbit_mat = this.model_mat = this.current_model_mat = Mat44.ident();
        this.mouse_drag = this.auto_spin = false;
        this.auto_rotate = true;
        this.mouse_start = [0, 0];
        this.mouse_drag_axis = [0, 0, 0];
        this.mouse_drag_angle = 0;
        this.mouse_drag_time = 0;
        this.drag_start_T = this.rotate_start_T = this.time;

        this.domElement = document;
        var cam = this;
        this.domElement.addEventListener( 'mousedown', function(e) { cam.OnMouseDown(e) }, false );
        this.domElement.addEventListener( 'mouseup', function(e) { cam.OnMouseUp(e) }, false );
        this.domElement.addEventListener( 'mousemove', function(e) { cam.OnMouseMove(e) }, false );
        //this.domElement.addEventListener( 'contextmenu', function(e) { event.preventDefault(); }, false );
        //this.domElement.addEventListener( 'mousewheel', hid_events.onMouseWheel, false );
        //this.domElement.addEventListener( 'DOMMouseScroll', hid_events.onMouseWheel, false ); // firefox
    }

    get time() { return Date.now(); }
        
    get ortho() {
        let fn = this.far + this.near;
        let f_n = this.far - this.near;
        let w = this.vp[0];
        let h = this.vp[1];
        let a = w/h;
        return [ 2/a, 0, 0, 0, 0, 2, 0, 0, 0, 0, -2/f_n, 0, 0, 0, -fn/f_n, 1 ];
    }  

    get perspective() {
        let n = this.near;
        let f = this.far;
        let fn = f + n;
        let f_n = f - n;
        let r = this.vp[0] / this.vp[1];
        let t = 1 / Math.tan( Math.PI * this.fov_y / 360 );
        return [ t/r, 0, 0, 0, 0, t, 0, 0, 0, 0, -fn/f_n, -1, 0, 0, -2*f*n/f_n, 0 ];
    } 

    get lookAt() {
        let mz = Vec3.normalize( [ this.pos[0]-this.target[0], this.pos[1]-this.target[1], this.pos[2]-this.target[2] ] );
        let mx = Vec3.normalize( Vec3.cross( this.up, mz ) );
        let my = Vec3.normalize( Vec3.cross( mz, mx ) );
        let tx = Vec3.dot( mx, this.pos );
        let ty = Vec3.dot( my, this.pos );
        let tz = Vec3.dot( [-mz[0], -mz[1], -mz[2]], this.pos ); 
        return [mx[0], my[0], mz[0], 0, mx[1], my[1], mz[1], 0, mx[2], my[2], mz[2], 0, tx, ty, tz, 1]; 
    }

    get orbit() {
      return Mat44.multiply(this.lookAt, this.orbitMatrix);
    }

    get orbitMatrix() {
      return (this.mouse_drag || (this.auto_rotate && this.auto_spin)) ? Mat44.multiply(this.current_orbit_mat, this.orbit_mat) : this.orbit_mat;
    }

    get autoModelMatrix() {
      return this.auto_rotate ? Mat44.multiply(this.current_model_mat, this.model_mat) : this.model_mat;
    }

    Update(vp_size) {
        if (vp_size)
            this.vp = vp_size;
        let current_T = this.time;
        this.current_model_mat = Mat44.ident()
        if (this.mouse_drag) {
            this.current_orbit_mat = Mat44.rotate(Mat44.ident(), this.mouse_drag_angle, this.mouse_drag_axis);
        } else if (this.auto_rotate) {
            if (this.auto_spin ) {
                if (this.mouse_drag_time > 0 ) {
                    let angle = this.mouse_drag_angle * (current_T - this.rotate_start_T) / this.mouse_drag_time;
                    this.current_orbit_mat = Mat44.rotate(Mat44.ident(), angle, this.mouse_drag_axis);
                }
            } else {
                let auto_angle_x = Util.fract( (current_T - this.rotate_start_T) / 13000.0 ) * 2.0 * Math.PI;
                let auto_angle_y = Util.fract( (current_T - this.rotate_start_T) / 17000.0 ) * 2.0 * Math.PI;
                this.current_model_mat = Mat44.rotateAxis( this.current_model_mat, auto_angle_x, 0 );
                this.current_model_mat = Mat44.rotateAxis( this.current_model_mat, auto_angle_y, 1 );
            }
        }
    }

    ChangeMotionMode(drag, spin, auto ) {
        let new_drag = drag;
        let new_auto = new_drag ? false : auto;
        let new_spin = new_auto ? spin : false;
        let change = this.mouse_drag != new_drag || this.auto_rotate != new_auto || this.auto_spin != new_spin; 
        if (!change)
            return;
        if (new_drag && !this.mouse_drag) {
            this.drag_start_T = this.time;
            this.mouse_drag_angle = 0.0;
            this.mouse_drag_time = 0;
        }
        if (new_auto && !this.auto_rotate)
            this.rotate_start_T = this.time;
        this.mouse_drag = new_drag; 
        this.auto_rotate = new_auto;  
        this.auto_spin = new_spin;
        this.orbit_mat = Mat44.multiply(this.current_orbit_mat, this.orbit_mat);
        this.current_orbit_mat = Mat44.ident();
        this.model_mat = Mat44.multiply(this.current_model_mat, this.model_mat);
        this.current_model_mat = Mat44.ident();
    }

    OnMouseDown( event ) {
        let rect = gl.canvas.getBoundingClientRect();
        if ( event.clientX < rect.left || event.clientX > rect.right ) return;
        if ( event.clientY < rect.top || event.clientY > rect.bottom ) return;
        if (event.button == 0) { // left button
            this.mouse_start = [event.clientX, event.clientY]; 
            this.ChangeMotionMode( true, false, false );
        }
    }

    OnMouseUp( event ) {
        if (event.button == 0) { // left button
            this.ChangeMotionMode( false, true, true );
        } else if (event.button == 1) {// middle button
            this.ChangeMotionMode( false, false, !this.auto_rotate );
        }
    }

    OnMouseMove( event ) {
        let dx = (event.clientX-this.mouse_start[0]) / this.vp[0];
        let dy = (event.clientY-this.mouse_start[1]) / this.vp[1];
        let len = Math.sqrt(dx*dx + dy*dy);
        if (this.mouse_drag && len > 0) {
            this.mouse_drag_angle = Math.PI*len;
            this.mouse_drag_axis = [-dy/len, 0, dx/len];
            this.mouse_drag_time = this.time - this.drag_start_T;
        }
    }
}

let Util = {
fract : function( val ) { 
  return val - Math.trunc( val );
},
angle : function( deltaTime, intervall ) {
  return this.fract( deltaTime / (1000*intervall) ) * 2.0 * Math.PI;
},
move : function( deltaTime, intervall, range ) {
  var pos = this.fract( deltaTime / (1000*intervall) ) * 2.0
  var pos = pos < 1.0 ? pos : (2.0-pos)
  return range[0] + (range[1] - range[0]) * pos;
},    
ellipticalPosition : function( a, b, angRag ) {
  var a_b = a * a - b * b
  var ea = (a_b <= 0) ? 0 : Math.sqrt( a_b );
  var eb = (a_b >= 0) ? 0 : Math.sqrt( -a_b );
  return [ a * Math.sin( angRag ) - ea, b * Math.cos( angRag ) - eb, 0 ];
}
}

Vec3 = {
    mul_s: function( v, s ) { return [v[0]*s, v[1]*s, v[2]*s]; },
    add: function( a, b ) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; },
    sub: function( a, b ) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; },
    cross: function( a, b ) { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; },
    dot: function( a, b ) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; },
    len: function( v ) { return Math.sqrt( v[0] * v[0] + v[1] * v[1] + v[2] * v[2] ); },
    normalize: function( v ) {
        var len = this.len( v );
        return [ v[0] / len, v[1] / len, v[2] / len ];
    }
}

Mat44 = {
ident: function() { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; },
rotateAxis: function(matA, angRad, axis) {
  var aMap = [ [1, 2], [2, 0], [0, 1] ];
  var a0 = aMap[axis][0], a1 = aMap[axis][1]; 
  var sinAng = Math.sin(angRad), cosAng = Math.cos(angRad);
  var matB = matA.slice(0);
  for ( var i = 0; i < 3; ++ i ) {
      matB[a0*4+i] = matA[a0*4+i] * cosAng + matA[a1*4+i] * sinAng;
      matB[a1*4+i] = matA[a0*4+i] * -sinAng + matA[a1*4+i] * cosAng;
  }
  return matB;
},
rotate: function(matA, angRad, axis) {
    var s = Math.sin(-angRad), c = Math.cos(-angRad);
    var x = axis[0], y = axis[1], z = axis[2]; 
    matB = [
        x*x*(1-c)+c,   x*y*(1-c)-z*s, x*z*(1-c)+y*s, 0,
        y*x*(1-c)+z*s, y*y*(1-c)+c,   y*z*(1-c)-x*s, 0,
        z*x*(1-c)-y*s, z*y*(1-c)+x*s, z*z*(1-c)+c,   0,
        0,             0,             0,             1 ];
    return this.multiply(matA, matB);
},
multiply: function(matA, matB) {
  matC = this.ident();
  for (var i0=0; i0<4; ++i0 )
      for (var i1=0; i1<4; ++i1 )
          matC[i0*4+i1] = matB[i0*4+0] * matA[0*4+i1] + matB[i0*4+1] * matA[1*4+i1] + matB[i0*4+2] * matA[2*4+i1] + matB[i0*4+3] * matA[3*4+i1]  
  return matC;
},
transformVec3: function(mat, vec) {
    return [
        vec[0] * mat[0*4+0] + vec[1] * mat[1*4+0] + vec[2] * mat[2*4+0],
        vec[0] * mat[0*4+1] + vec[1] * mat[1*4+1] + vec[2] * mat[2*4+1],
        vec[0] * mat[0*4+2] + vec[1] * mat[1*4+2] + vec[2] * mat[2*4+2] ]
}
}

function render(deltaMS){
    app.draw(deltaMS);
    requestAnimationFrame(render);
}

let app = new App();
requestAnimationFrame(render);


})();
</script>

</body>